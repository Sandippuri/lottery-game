import credits.aleo;
import token_registry.aleo;
program lottery_game_puri.aleo;

struct TokenMetadata:
    token_id as field;
    name as u128;
    symbol as u128;
    decimals as u8;
    supply as u128;
    max_supply as u128;
    admin as address;
    external_authorization_required as boolean;
    external_authorization_party as address;

struct TokenOwner:
    account as address;
    token_id as field;

record Lottery:
    owner as address.private;
    lottery as [[u8; 5u32]; 5u32].private;
    days as u16.private;

struct LotteryHash:
    lottery as [u8; 5u32];
    day as u16;

mapping is_available:
    key as field.public;
    value as boolean.public;

mapping winner_number:
    key as u16.public;
    value as [u8; 5u32].public;

mapping user_balance:
    key as field.public;
    value as u64.public;

mapping user_token_balance:
    key as field.public;
    value as u64.public;

mapping cuurent_amount:
    key as boolean.public;
    value as u64.public;

mapping current_amount_token:
    key as field.public;
    value as u128.public;

mapping admin:
    key as boolean.public;
    value as address.public;

mapping status:
    key as boolean.public;
    value as u8.public;

mapping winning_price:
    key as boolean.public;
    value as [u64; 5u32].public;

function initialize:
    input r0 as address.private;
    input r1 as u64.private;
    gt r1 0u64 into r2;
    assert.eq r2 true;
    async initialize r0 r1 into r3;
    output r3 as lottery_game_puri.aleo/initialize.future;

finalize initialize:
    input r0 as address.public;
    input r1 as u64.public;
    contains admin[true] into r2;
    not r2 into r3;
    assert.eq r3 true;
    set r0 into admin[true];
    set r1 into cuurent_amount[true];
    set 0u8 into status[true];
    cast  0u8 0u8 0u8 0u8 0u8 into r4 as [u8; 5u32];
    cast r4 1u16 into r5 as LotteryHash;
    hash.bhp256 r5 into r6 as field;
    set true into is_available[r6];

function set_winning_price:
    input r0 as [u64; 5u32].private;
    async set_winning_price self.caller r0 into r1;
    output r1 as lottery_game_puri.aleo/set_winning_price.future;

finalize set_winning_price:
    input r0 as address.public;
    input r1 as [u64; 5u32].public;
    get admin[true] into r2;
    assert.eq r0 r2;
    set r1 into winning_price[true];

function set_token_price:
    input r0 as field.private;
    input r1 as u128.private;
    gt r1 0u128 into r2;
    assert.eq r2 true;
    async set_token_price self.caller r1 r0 into r3;
    output r3 as lottery_game_puri.aleo/set_token_price.future;

finalize set_token_price:
    input r0 as address.public;
    input r1 as u128.public;
    input r2 as field.public;
    contains admin[true] into r3;
    not r3 into r4;
    assert.eq r4 true;
    set r0 into admin[true];
    set r1 into current_amount_token[r2];

function buy_public:
    input r0 as [u64; 5u32].private;
    input r1 as [[u8; 5u32]; 5u32].private;
    input r2 as u16.private;
    lte r1[0u32][0u32] 32u8 into r3;
    assert.eq r3 true;
    lte r1[0u32][1u32] 32u8 into r4;
    assert.eq r4 true;
    lte r1[0u32][2u32] 32u8 into r5;
    assert.eq r5 true;
    lte r1[0u32][3u32] 32u8 into r6;
    assert.eq r6 true;
    lte r1[0u32][4u32] 32u8 into r7;
    assert.eq r7 true;
    lte r1[1u32][0u32] 32u8 into r8;
    assert.eq r8 true;
    lte r1[1u32][1u32] 32u8 into r9;
    assert.eq r9 true;
    lte r1[1u32][2u32] 32u8 into r10;
    assert.eq r10 true;
    lte r1[1u32][3u32] 32u8 into r11;
    assert.eq r11 true;
    lte r1[1u32][4u32] 32u8 into r12;
    assert.eq r12 true;
    lte r1[2u32][0u32] 32u8 into r13;
    assert.eq r13 true;
    lte r1[2u32][1u32] 32u8 into r14;
    assert.eq r14 true;
    lte r1[2u32][2u32] 32u8 into r15;
    assert.eq r15 true;
    lte r1[2u32][3u32] 32u8 into r16;
    assert.eq r16 true;
    lte r1[2u32][4u32] 32u8 into r17;
    assert.eq r17 true;
    lte r1[3u32][0u32] 32u8 into r18;
    assert.eq r18 true;
    lte r1[3u32][1u32] 32u8 into r19;
    assert.eq r19 true;
    lte r1[3u32][2u32] 32u8 into r20;
    assert.eq r20 true;
    lte r1[3u32][3u32] 32u8 into r21;
    assert.eq r21 true;
    lte r1[3u32][4u32] 32u8 into r22;
    assert.eq r22 true;
    lte r1[4u32][0u32] 32u8 into r23;
    assert.eq r23 true;
    lte r1[4u32][1u32] 32u8 into r24;
    assert.eq r24 true;
    lte r1[4u32][2u32] 32u8 into r25;
    assert.eq r25 true;
    lte r1[4u32][3u32] 32u8 into r26;
    assert.eq r26 true;
    lte r1[4u32][4u32] 32u8 into r27;
    assert.eq r27 true;
    add 0u64 r0[0u32] into r28;
    add r28 r0[1u32] into r29;
    add r29 r0[2u32] into r30;
    add r30 r0[3u32] into r31;
    add r31 r0[4u32] into r32;
    cast self.caller r1 r2 into r33 as Lottery.record;
    cast r1[0u32] r2 into r34 as LotteryHash;
    hash.bhp256 r34 into r35 as field;
    cast r1[1u32] r2 into r36 as LotteryHash;
    hash.bhp256 r36 into r37 as field;
    cast r1[2u32] r2 into r38 as LotteryHash;
    hash.bhp256 r38 into r39 as field;
    cast r1[3u32] r2 into r40 as LotteryHash;
    hash.bhp256 r40 into r41 as field;
    cast r1[4u32] r2 into r42 as LotteryHash;
    hash.bhp256 r42 into r43 as field;
    cast  r35 r37 r39 r41 r43 into r44 as [field; 5u32];
    call credits.aleo/transfer_public_as_signer lottery_game_puri.aleo r32 into r45;
    async buy_public r45 r32 r2 r44 r1[0u32] into r46;
    output r33 as Lottery.record;
    output r46 as lottery_game_puri.aleo/buy_public.future;

finalize buy_public:
    input r0 as credits.aleo/transfer_public_as_signer.future;
    input r1 as u64.public;
    input r2 as u16.public;
    input r3 as [field; 5u32].public;
    input r4 as [u8; 5u32].public;
    await r0;
    contains winner_number[r2] into r5;
    assert.eq r5 false;
    get status[true] into r6;
    assert.eq r6 1u8;
    get cuurent_amount[true] into r7;
    rem r1 r7 into r8;
    assert.eq r8 0u64;
    cast  0u8 0u8 0u8 0u8 0u8 into r9 as [u8; 5u32];
    cast r9 r2 into r10 as LotteryHash;
    hash.bhp256 r10 into r11 as field;
    is.neq r3[0u32] r11 into r12;
    branch.eq r12 false to end_then_0_0;
    contains is_available[r3[0u32]] into r13;
    assert.eq r13 false;
    set true into is_available[r3[0u32]];
    branch.eq true true to end_otherwise_0_1;
    position end_then_0_0;
    position end_otherwise_0_1;
    is.neq r3[1u32] r11 into r14;
    branch.eq r14 false to end_then_0_2;
    contains is_available[r3[1u32]] into r15;
    assert.eq r15 false;
    set true into is_available[r3[1u32]];
    branch.eq true true to end_otherwise_0_3;
    position end_then_0_2;
    position end_otherwise_0_3;
    is.neq r3[2u32] r11 into r16;
    branch.eq r16 false to end_then_0_4;
    contains is_available[r3[2u32]] into r17;
    assert.eq r17 false;
    set true into is_available[r3[2u32]];
    branch.eq true true to end_otherwise_0_5;
    position end_then_0_4;
    position end_otherwise_0_5;
    is.neq r3[3u32] r11 into r18;
    branch.eq r18 false to end_then_0_6;
    contains is_available[r3[3u32]] into r19;
    assert.eq r19 false;
    set true into is_available[r3[3u32]];
    branch.eq true true to end_otherwise_0_7;
    position end_then_0_6;
    position end_otherwise_0_7;
    is.neq r3[4u32] r11 into r20;
    branch.eq r20 false to end_then_0_8;
    contains is_available[r3[4u32]] into r21;
    assert.eq r21 false;
    set true into is_available[r3[4u32]];
    branch.eq true true to end_otherwise_0_9;
    position end_then_0_8;
    position end_otherwise_0_9;

function buy_public_token:
    input r0 as [u128; 5u32].private;
    input r1 as [[u8; 5u32]; 5u32].private;
    input r2 as u16.private;
    input r3 as field.private;
    lte r1[0u32][0u32] 32u8 into r4;
    assert.eq r4 true;
    lte r1[0u32][1u32] 32u8 into r5;
    assert.eq r5 true;
    lte r1[0u32][2u32] 32u8 into r6;
    assert.eq r6 true;
    lte r1[0u32][3u32] 32u8 into r7;
    assert.eq r7 true;
    lte r1[0u32][4u32] 32u8 into r8;
    assert.eq r8 true;
    lte r1[1u32][0u32] 32u8 into r9;
    assert.eq r9 true;
    lte r1[1u32][1u32] 32u8 into r10;
    assert.eq r10 true;
    lte r1[1u32][2u32] 32u8 into r11;
    assert.eq r11 true;
    lte r1[1u32][3u32] 32u8 into r12;
    assert.eq r12 true;
    lte r1[1u32][4u32] 32u8 into r13;
    assert.eq r13 true;
    lte r1[2u32][0u32] 32u8 into r14;
    assert.eq r14 true;
    lte r1[2u32][1u32] 32u8 into r15;
    assert.eq r15 true;
    lte r1[2u32][2u32] 32u8 into r16;
    assert.eq r16 true;
    lte r1[2u32][3u32] 32u8 into r17;
    assert.eq r17 true;
    lte r1[2u32][4u32] 32u8 into r18;
    assert.eq r18 true;
    lte r1[3u32][0u32] 32u8 into r19;
    assert.eq r19 true;
    lte r1[3u32][1u32] 32u8 into r20;
    assert.eq r20 true;
    lte r1[3u32][2u32] 32u8 into r21;
    assert.eq r21 true;
    lte r1[3u32][3u32] 32u8 into r22;
    assert.eq r22 true;
    lte r1[3u32][4u32] 32u8 into r23;
    assert.eq r23 true;
    lte r1[4u32][0u32] 32u8 into r24;
    assert.eq r24 true;
    lte r1[4u32][1u32] 32u8 into r25;
    assert.eq r25 true;
    lte r1[4u32][2u32] 32u8 into r26;
    assert.eq r26 true;
    lte r1[4u32][3u32] 32u8 into r27;
    assert.eq r27 true;
    lte r1[4u32][4u32] 32u8 into r28;
    assert.eq r28 true;
    add 0u128 r0[0u32] into r29;
    add r29 r0[1u32] into r30;
    add r30 r0[2u32] into r31;
    add r31 r0[3u32] into r32;
    add r32 r0[4u32] into r33;
    cast self.caller r1 r2 into r34 as Lottery.record;
    cast r1[0u32] r2 into r35 as LotteryHash;
    hash.bhp256 r35 into r36 as field;
    cast r1[1u32] r2 into r37 as LotteryHash;
    hash.bhp256 r37 into r38 as field;
    cast r1[2u32] r2 into r39 as LotteryHash;
    hash.bhp256 r39 into r40 as field;
    cast r1[3u32] r2 into r41 as LotteryHash;
    hash.bhp256 r41 into r42 as field;
    cast r1[4u32] r2 into r43 as LotteryHash;
    hash.bhp256 r43 into r44 as field;
    cast  r36 r38 r40 r42 r44 into r45 as [field; 5u32];
    call token_registry.aleo/transfer_public_as_signer r3 lottery_game_puri.aleo r33 into r46;
    async buy_public_token r46 r33 r2 r45 r1[0u32] r3 into r47;
    output r34 as Lottery.record;
    output r47 as lottery_game_puri.aleo/buy_public_token.future;

finalize buy_public_token:
    input r0 as token_registry.aleo/transfer_public_as_signer.future;
    input r1 as u128.public;
    input r2 as u16.public;
    input r3 as [field; 5u32].public;
    input r4 as [u8; 5u32].public;
    input r5 as field.public;
    await r0;
    contains winner_number[r2] into r6;
    assert.eq r6 false;
    get status[true] into r7;
    assert.eq r7 1u8;
    get current_amount_token[r5] into r8;
    rem r1 r8 into r9;
    assert.eq r9 0u128;
    cast  0u8 0u8 0u8 0u8 0u8 into r10 as [u8; 5u32];
    cast r10 r2 into r11 as LotteryHash;
    hash.bhp256 r11 into r12 as field;
    is.neq r3[0u32] r12 into r13;
    branch.eq r13 false to end_then_0_10;
    contains is_available[r3[0u32]] into r14;
    assert.eq r14 false;
    set true into is_available[r3[0u32]];
    branch.eq true true to end_otherwise_0_11;
    position end_then_0_10;
    position end_otherwise_0_11;
    is.neq r3[1u32] r12 into r15;
    branch.eq r15 false to end_then_0_12;
    contains is_available[r3[1u32]] into r16;
    assert.eq r16 false;
    set true into is_available[r3[1u32]];
    branch.eq true true to end_otherwise_0_13;
    position end_then_0_12;
    position end_otherwise_0_13;
    is.neq r3[2u32] r12 into r17;
    branch.eq r17 false to end_then_0_14;
    contains is_available[r3[2u32]] into r18;
    assert.eq r18 false;
    set true into is_available[r3[2u32]];
    branch.eq true true to end_otherwise_0_15;
    position end_then_0_14;
    position end_otherwise_0_15;
    is.neq r3[3u32] r12 into r19;
    branch.eq r19 false to end_then_0_16;
    contains is_available[r3[3u32]] into r20;
    assert.eq r20 false;
    set true into is_available[r3[3u32]];
    branch.eq true true to end_otherwise_0_17;
    position end_then_0_16;
    position end_otherwise_0_17;
    is.neq r3[4u32] r12 into r21;
    branch.eq r21 false to end_then_0_18;
    contains is_available[r3[4u32]] into r22;
    assert.eq r22 false;
    set true into is_available[r3[4u32]];
    branch.eq true true to end_otherwise_0_19;
    position end_then_0_18;
    position end_otherwise_0_19;

function buy_private:
    input r0 as credits.aleo/credits.record;
    input r1 as [u64; 5u32].private;
    input r2 as [[u8; 5u32]; 5u32].private;
    input r3 as u16.private;
    lt r2[0u32][0u32] 32u8 into r4;
    assert.eq r4 true;
    lt r2[0u32][1u32] 32u8 into r5;
    assert.eq r5 true;
    lt r2[0u32][2u32] 32u8 into r6;
    assert.eq r6 true;
    lt r2[0u32][3u32] 32u8 into r7;
    assert.eq r7 true;
    lt r2[0u32][4u32] 32u8 into r8;
    assert.eq r8 true;
    lt r2[1u32][0u32] 32u8 into r9;
    assert.eq r9 true;
    lt r2[1u32][1u32] 32u8 into r10;
    assert.eq r10 true;
    lt r2[1u32][2u32] 32u8 into r11;
    assert.eq r11 true;
    lt r2[1u32][3u32] 32u8 into r12;
    assert.eq r12 true;
    lt r2[1u32][4u32] 32u8 into r13;
    assert.eq r13 true;
    lt r2[2u32][0u32] 32u8 into r14;
    assert.eq r14 true;
    lt r2[2u32][1u32] 32u8 into r15;
    assert.eq r15 true;
    lt r2[2u32][2u32] 32u8 into r16;
    assert.eq r16 true;
    lt r2[2u32][3u32] 32u8 into r17;
    assert.eq r17 true;
    lt r2[2u32][4u32] 32u8 into r18;
    assert.eq r18 true;
    lt r2[3u32][0u32] 32u8 into r19;
    assert.eq r19 true;
    lt r2[3u32][1u32] 32u8 into r20;
    assert.eq r20 true;
    lt r2[3u32][2u32] 32u8 into r21;
    assert.eq r21 true;
    lt r2[3u32][3u32] 32u8 into r22;
    assert.eq r22 true;
    lt r2[3u32][4u32] 32u8 into r23;
    assert.eq r23 true;
    lt r2[4u32][0u32] 32u8 into r24;
    assert.eq r24 true;
    lt r2[4u32][1u32] 32u8 into r25;
    assert.eq r25 true;
    lt r2[4u32][2u32] 32u8 into r26;
    assert.eq r26 true;
    lt r2[4u32][3u32] 32u8 into r27;
    assert.eq r27 true;
    lt r2[4u32][4u32] 32u8 into r28;
    assert.eq r28 true;
    add 0u64 r1[0u32] into r29;
    add r29 r1[1u32] into r30;
    add r30 r1[2u32] into r31;
    add r31 r1[3u32] into r32;
    add r32 r1[4u32] into r33;
    cast self.caller r2 r3 into r34 as Lottery.record;
    call credits.aleo/transfer_private_to_public r0 lottery_game_puri.aleo r33 into r35 r36;
    hash.bhp256 r2[0u32] into r37 as field;
    hash.bhp256 r2[1u32] into r38 as field;
    hash.bhp256 r2[2u32] into r39 as field;
    hash.bhp256 r2[3u32] into r40 as field;
    hash.bhp256 r2[4u32] into r41 as field;
    cast  r37 r38 r39 r40 r41 into r42 as [field; 5u32];
    async buy_private r42 r33 r36 r3 into r43;
    output r34 as Lottery.record;
    output r35 as credits.aleo/credits.record;
    output r43 as lottery_game_puri.aleo/buy_private.future;

finalize buy_private:
    input r0 as [field; 5u32].public;
    input r1 as u64.public;
    input r2 as credits.aleo/transfer_private_to_public.future;
    input r3 as u16.public;
    await r2;
    contains winner_number[r3] into r4;
    not r4 into r5;
    assert.eq r5 true;
    get status[true] into r6;
    assert.eq r6 1u8;
    get cuurent_amount[true] into r7;
    rem r1 r7 into r8;
    assert.eq r8 0u64;
    cast  0u8 0u8 0u8 0u8 0u8 into r9 as [u8; 5u32];
    cast r9 r3 into r10 as LotteryHash;
    hash.bhp256 r10 into r11 as field;
    is.neq r0[0u32] r11 into r12;
    branch.eq r12 false to end_then_0_20;
    contains is_available[r0[0u32]] into r13;
    not r13 into r14;
    assert.eq r14 true;
    set true into is_available[r0[0u32]];
    branch.eq true true to end_otherwise_0_21;
    position end_then_0_20;
    position end_otherwise_0_21;
    is.neq r0[1u32] r11 into r15;
    branch.eq r15 false to end_then_0_22;
    contains is_available[r0[1u32]] into r16;
    not r16 into r17;
    assert.eq r17 true;
    set true into is_available[r0[1u32]];
    branch.eq true true to end_otherwise_0_23;
    position end_then_0_22;
    position end_otherwise_0_23;
    is.neq r0[2u32] r11 into r18;
    branch.eq r18 false to end_then_0_24;
    contains is_available[r0[2u32]] into r19;
    not r19 into r20;
    assert.eq r20 true;
    set true into is_available[r0[2u32]];
    branch.eq true true to end_otherwise_0_25;
    position end_then_0_24;
    position end_otherwise_0_25;
    is.neq r0[3u32] r11 into r21;
    branch.eq r21 false to end_then_0_26;
    contains is_available[r0[3u32]] into r22;
    not r22 into r23;
    assert.eq r23 true;
    set true into is_available[r0[3u32]];
    branch.eq true true to end_otherwise_0_27;
    position end_then_0_26;
    position end_otherwise_0_27;
    is.neq r0[4u32] r11 into r24;
    branch.eq r24 false to end_then_0_28;
    contains is_available[r0[4u32]] into r25;
    not r25 into r26;
    assert.eq r26 true;
    set true into is_available[r0[4u32]];
    branch.eq true true to end_otherwise_0_29;
    position end_then_0_28;
    position end_otherwise_0_29;

function buy_private_token:
    input r0 as token_registry.aleo/Token.record;
    input r1 as [u64; 5u32].private;
    input r2 as [[u8; 5u32]; 5u32].private;
    input r3 as u16.private;
    lt r2[0u32][0u32] 32u8 into r4;
    assert.eq r4 true;
    lt r2[0u32][1u32] 32u8 into r5;
    assert.eq r5 true;
    lt r2[0u32][2u32] 32u8 into r6;
    assert.eq r6 true;
    lt r2[0u32][3u32] 32u8 into r7;
    assert.eq r7 true;
    lt r2[0u32][4u32] 32u8 into r8;
    assert.eq r8 true;
    lt r2[1u32][0u32] 32u8 into r9;
    assert.eq r9 true;
    lt r2[1u32][1u32] 32u8 into r10;
    assert.eq r10 true;
    lt r2[1u32][2u32] 32u8 into r11;
    assert.eq r11 true;
    lt r2[1u32][3u32] 32u8 into r12;
    assert.eq r12 true;
    lt r2[1u32][4u32] 32u8 into r13;
    assert.eq r13 true;
    lt r2[2u32][0u32] 32u8 into r14;
    assert.eq r14 true;
    lt r2[2u32][1u32] 32u8 into r15;
    assert.eq r15 true;
    lt r2[2u32][2u32] 32u8 into r16;
    assert.eq r16 true;
    lt r2[2u32][3u32] 32u8 into r17;
    assert.eq r17 true;
    lt r2[2u32][4u32] 32u8 into r18;
    assert.eq r18 true;
    lt r2[3u32][0u32] 32u8 into r19;
    assert.eq r19 true;
    lt r2[3u32][1u32] 32u8 into r20;
    assert.eq r20 true;
    lt r2[3u32][2u32] 32u8 into r21;
    assert.eq r21 true;
    lt r2[3u32][3u32] 32u8 into r22;
    assert.eq r22 true;
    lt r2[3u32][4u32] 32u8 into r23;
    assert.eq r23 true;
    lt r2[4u32][0u32] 32u8 into r24;
    assert.eq r24 true;
    lt r2[4u32][1u32] 32u8 into r25;
    assert.eq r25 true;
    lt r2[4u32][2u32] 32u8 into r26;
    assert.eq r26 true;
    lt r2[4u32][3u32] 32u8 into r27;
    assert.eq r27 true;
    lt r2[4u32][4u32] 32u8 into r28;
    assert.eq r28 true;
    add 0u64 r1[0u32] into r29;
    add r29 r1[1u32] into r30;
    add r30 r1[2u32] into r31;
    add r31 r1[3u32] into r32;
    add r32 r1[4u32] into r33;
    cast self.caller r2 r3 into r34 as Lottery.record;
    cast r33 into r35 as u128;
    call token_registry.aleo/transfer_private_to_public lottery_game_puri.aleo r35 r0 into r36 r37;
    hash.bhp256 r2[0u32] into r38 as field;
    hash.bhp256 r2[1u32] into r39 as field;
    hash.bhp256 r2[2u32] into r40 as field;
    hash.bhp256 r2[3u32] into r41 as field;
    hash.bhp256 r2[4u32] into r42 as field;
    cast  r38 r39 r40 r41 r42 into r43 as [field; 5u32];
    async buy_private_token r43 r33 r37 r3 r0.token_id into r44;
    output r34 as Lottery.record;
    output r36 as token_registry.aleo/Token.record;
    output r44 as lottery_game_puri.aleo/buy_private_token.future;

finalize buy_private_token:
    input r0 as [field; 5u32].public;
    input r1 as u64.public;
    input r2 as token_registry.aleo/transfer_private_to_public.future;
    input r3 as u16.public;
    input r4 as field.public;
    await r2;
    contains winner_number[r3] into r5;
    not r5 into r6;
    assert.eq r6 true;
    get status[true] into r7;
    assert.eq r7 1u8;
    cast r1 into r8 as u128;
    get current_amount_token[r4] into r9;
    rem r8 r9 into r10;
    assert.eq r10 0u128;
    cast  0u8 0u8 0u8 0u8 0u8 into r11 as [u8; 5u32];
    cast r11 r3 into r12 as LotteryHash;
    hash.bhp256 r12 into r13 as field;
    is.neq r0[0u32] r13 into r14;
    branch.eq r14 false to end_then_0_30;
    contains is_available[r0[0u32]] into r15;
    not r15 into r16;
    assert.eq r16 true;
    set true into is_available[r0[0u32]];
    branch.eq true true to end_otherwise_0_31;
    position end_then_0_30;
    position end_otherwise_0_31;
    is.neq r0[1u32] r13 into r17;
    branch.eq r17 false to end_then_0_32;
    contains is_available[r0[1u32]] into r18;
    not r18 into r19;
    assert.eq r19 true;
    set true into is_available[r0[1u32]];
    branch.eq true true to end_otherwise_0_33;
    position end_then_0_32;
    position end_otherwise_0_33;
    is.neq r0[2u32] r13 into r20;
    branch.eq r20 false to end_then_0_34;
    contains is_available[r0[2u32]] into r21;
    not r21 into r22;
    assert.eq r22 true;
    set true into is_available[r0[2u32]];
    branch.eq true true to end_otherwise_0_35;
    position end_then_0_34;
    position end_otherwise_0_35;
    is.neq r0[3u32] r13 into r23;
    branch.eq r23 false to end_then_0_36;
    contains is_available[r0[3u32]] into r24;
    not r24 into r25;
    assert.eq r25 true;
    set true into is_available[r0[3u32]];
    branch.eq true true to end_otherwise_0_37;
    position end_then_0_36;
    position end_otherwise_0_37;
    is.neq r0[4u32] r13 into r26;
    branch.eq r26 false to end_then_0_38;
    contains is_available[r0[4u32]] into r27;
    not r27 into r28;
    assert.eq r28 true;
    set true into is_available[r0[4u32]];
    branch.eq true true to end_otherwise_0_39;
    position end_then_0_38;
    position end_otherwise_0_39;

function generate_winner:
    input r0 as u16.private;
    async generate_winner r0 self.caller into r1;
    output r1 as lottery_game_puri.aleo/generate_winner.future;

finalize generate_winner:
    input r0 as u16.public;
    input r1 as address.public;
    get status[true] into r2;
    assert.eq r2 1u8;
    get admin[true] into r3;
    assert.eq r1 r3;
    rand.chacha into r4 as u8;
    add 32u8 1u8 into r5;
    rem r4 r5 into r6;
    rand.chacha into r7 as u8;
    add 32u8 1u8 into r8;
    rem r7 r8 into r9;
    rand.chacha into r10 as u8;
    add 32u8 1u8 into r11;
    rem r10 r11 into r12;
    rand.chacha into r13 as u8;
    add 32u8 1u8 into r14;
    rem r13 r14 into r15;
    rand.chacha into r16 as u8;
    add 32u8 1u8 into r17;
    rem r16 r17 into r18;
    cast  r6 r9 r12 r15 r18 into r19 as [u8; 5u32];
    set r19 into winner_number[r0];
    cast  0u8 0u8 0u8 0u8 0u8 into r20 as [u8; 5u32];
    cast r20 r0 into r21 as LotteryHash;
    hash.bhp256 r21 into r22 as field;
    set true into is_available[r22];

function match_lottery:
    input r0 as Lottery.record;
    hash.bhp256 r0.owner into r1 as field;
    async match_lottery r1 r0.lottery r0.days into r2;
    output r2 as lottery_game_puri.aleo/match_lottery.future;

finalize match_lottery:
    input r0 as field.public;
    input r1 as [[u8; 5u32]; 5u32].public;
    input r2 as u16.public;
    add r2 7u16 into r3;
    lt r2 r3 into r4;
    assert.eq r4 true;
    get status[true] into r5;
    assert.eq r5 1u8;
    get winner_number[r2] into r6;
    is.eq r1[0u32][0u32] r6[0u32] into r7;
    add 0u8 1u8 into r8;
    ternary r7 r8 0u8 into r9;
    is.eq r1[0u32][0u32] r6[1u32] into r10;
    add r9 1u8 into r11;
    ternary r10 r11 r9 into r12;
    is.eq r1[0u32][0u32] r6[2u32] into r13;
    add r12 1u8 into r14;
    ternary r13 r14 r12 into r15;
    is.eq r1[0u32][0u32] r6[3u32] into r16;
    add r15 1u8 into r17;
    ternary r16 r17 r15 into r18;
    is.eq r1[0u32][0u32] r6[4u32] into r19;
    add r18 1u8 into r20;
    ternary r19 r20 r18 into r21;
    is.eq r1[0u32][1u32] r6[0u32] into r22;
    add r21 1u8 into r23;
    ternary r22 r23 r21 into r24;
    is.eq r1[0u32][1u32] r6[1u32] into r25;
    add r24 1u8 into r26;
    ternary r25 r26 r24 into r27;
    is.eq r1[0u32][1u32] r6[2u32] into r28;
    add r27 1u8 into r29;
    ternary r28 r29 r27 into r30;
    is.eq r1[0u32][1u32] r6[3u32] into r31;
    add r30 1u8 into r32;
    ternary r31 r32 r30 into r33;
    is.eq r1[0u32][1u32] r6[4u32] into r34;
    add r33 1u8 into r35;
    ternary r34 r35 r33 into r36;
    is.eq r1[0u32][2u32] r6[0u32] into r37;
    add r36 1u8 into r38;
    ternary r37 r38 r36 into r39;
    is.eq r1[0u32][2u32] r6[1u32] into r40;
    add r39 1u8 into r41;
    ternary r40 r41 r39 into r42;
    is.eq r1[0u32][2u32] r6[2u32] into r43;
    add r42 1u8 into r44;
    ternary r43 r44 r42 into r45;
    is.eq r1[0u32][2u32] r6[3u32] into r46;
    add r45 1u8 into r47;
    ternary r46 r47 r45 into r48;
    is.eq r1[0u32][2u32] r6[4u32] into r49;
    add r48 1u8 into r50;
    ternary r49 r50 r48 into r51;
    is.eq r1[0u32][3u32] r6[0u32] into r52;
    add r51 1u8 into r53;
    ternary r52 r53 r51 into r54;
    is.eq r1[0u32][3u32] r6[1u32] into r55;
    add r54 1u8 into r56;
    ternary r55 r56 r54 into r57;
    is.eq r1[0u32][3u32] r6[2u32] into r58;
    add r57 1u8 into r59;
    ternary r58 r59 r57 into r60;
    is.eq r1[0u32][3u32] r6[3u32] into r61;
    add r60 1u8 into r62;
    ternary r61 r62 r60 into r63;
    is.eq r1[0u32][3u32] r6[4u32] into r64;
    add r63 1u8 into r65;
    ternary r64 r65 r63 into r66;
    is.eq r1[0u32][4u32] r6[0u32] into r67;
    add r66 1u8 into r68;
    ternary r67 r68 r66 into r69;
    is.eq r1[0u32][4u32] r6[1u32] into r70;
    add r69 1u8 into r71;
    ternary r70 r71 r69 into r72;
    is.eq r1[0u32][4u32] r6[2u32] into r73;
    add r72 1u8 into r74;
    ternary r73 r74 r72 into r75;
    is.eq r1[0u32][4u32] r6[3u32] into r76;
    add r75 1u8 into r77;
    ternary r76 r77 r75 into r78;
    is.eq r1[0u32][4u32] r6[4u32] into r79;
    add r78 1u8 into r80;
    ternary r79 r80 r78 into r81;
    is.eq r1[1u32][0u32] r6[0u32] into r82;
    add 0u8 1u8 into r83;
    ternary r82 r83 0u8 into r84;
    is.eq r1[1u32][0u32] r6[1u32] into r85;
    add r84 1u8 into r86;
    ternary r85 r86 r84 into r87;
    is.eq r1[1u32][0u32] r6[2u32] into r88;
    add r87 1u8 into r89;
    ternary r88 r89 r87 into r90;
    is.eq r1[1u32][0u32] r6[3u32] into r91;
    add r90 1u8 into r92;
    ternary r91 r92 r90 into r93;
    is.eq r1[1u32][0u32] r6[4u32] into r94;
    add r93 1u8 into r95;
    ternary r94 r95 r93 into r96;
    is.eq r1[1u32][1u32] r6[0u32] into r97;
    add r96 1u8 into r98;
    ternary r97 r98 r96 into r99;
    is.eq r1[1u32][1u32] r6[1u32] into r100;
    add r99 1u8 into r101;
    ternary r100 r101 r99 into r102;
    is.eq r1[1u32][1u32] r6[2u32] into r103;
    add r102 1u8 into r104;
    ternary r103 r104 r102 into r105;
    is.eq r1[1u32][1u32] r6[3u32] into r106;
    add r105 1u8 into r107;
    ternary r106 r107 r105 into r108;
    is.eq r1[1u32][1u32] r6[4u32] into r109;
    add r108 1u8 into r110;
    ternary r109 r110 r108 into r111;
    is.eq r1[1u32][2u32] r6[0u32] into r112;
    add r111 1u8 into r113;
    ternary r112 r113 r111 into r114;
    is.eq r1[1u32][2u32] r6[1u32] into r115;
    add r114 1u8 into r116;
    ternary r115 r116 r114 into r117;
    is.eq r1[1u32][2u32] r6[2u32] into r118;
    add r117 1u8 into r119;
    ternary r118 r119 r117 into r120;
    is.eq r1[1u32][2u32] r6[3u32] into r121;
    add r120 1u8 into r122;
    ternary r121 r122 r120 into r123;
    is.eq r1[1u32][2u32] r6[4u32] into r124;
    add r123 1u8 into r125;
    ternary r124 r125 r123 into r126;
    is.eq r1[1u32][3u32] r6[0u32] into r127;
    add r126 1u8 into r128;
    ternary r127 r128 r126 into r129;
    is.eq r1[1u32][3u32] r6[1u32] into r130;
    add r129 1u8 into r131;
    ternary r130 r131 r129 into r132;
    is.eq r1[1u32][3u32] r6[2u32] into r133;
    add r132 1u8 into r134;
    ternary r133 r134 r132 into r135;
    is.eq r1[1u32][3u32] r6[3u32] into r136;
    add r135 1u8 into r137;
    ternary r136 r137 r135 into r138;
    is.eq r1[1u32][3u32] r6[4u32] into r139;
    add r138 1u8 into r140;
    ternary r139 r140 r138 into r141;
    is.eq r1[1u32][4u32] r6[0u32] into r142;
    add r141 1u8 into r143;
    ternary r142 r143 r141 into r144;
    is.eq r1[1u32][4u32] r6[1u32] into r145;
    add r144 1u8 into r146;
    ternary r145 r146 r144 into r147;
    is.eq r1[1u32][4u32] r6[2u32] into r148;
    add r147 1u8 into r149;
    ternary r148 r149 r147 into r150;
    is.eq r1[1u32][4u32] r6[3u32] into r151;
    add r150 1u8 into r152;
    ternary r151 r152 r150 into r153;
    is.eq r1[1u32][4u32] r6[4u32] into r154;
    add r153 1u8 into r155;
    ternary r154 r155 r153 into r156;
    is.eq r1[2u32][0u32] r6[0u32] into r157;
    add 0u8 1u8 into r158;
    ternary r157 r158 0u8 into r159;
    is.eq r1[2u32][0u32] r6[1u32] into r160;
    add r159 1u8 into r161;
    ternary r160 r161 r159 into r162;
    is.eq r1[2u32][0u32] r6[2u32] into r163;
    add r162 1u8 into r164;
    ternary r163 r164 r162 into r165;
    is.eq r1[2u32][0u32] r6[3u32] into r166;
    add r165 1u8 into r167;
    ternary r166 r167 r165 into r168;
    is.eq r1[2u32][0u32] r6[4u32] into r169;
    add r168 1u8 into r170;
    ternary r169 r170 r168 into r171;
    is.eq r1[2u32][1u32] r6[0u32] into r172;
    add r171 1u8 into r173;
    ternary r172 r173 r171 into r174;
    is.eq r1[2u32][1u32] r6[1u32] into r175;
    add r174 1u8 into r176;
    ternary r175 r176 r174 into r177;
    is.eq r1[2u32][1u32] r6[2u32] into r178;
    add r177 1u8 into r179;
    ternary r178 r179 r177 into r180;
    is.eq r1[2u32][1u32] r6[3u32] into r181;
    add r180 1u8 into r182;
    ternary r181 r182 r180 into r183;
    is.eq r1[2u32][1u32] r6[4u32] into r184;
    add r183 1u8 into r185;
    ternary r184 r185 r183 into r186;
    is.eq r1[2u32][2u32] r6[0u32] into r187;
    add r186 1u8 into r188;
    ternary r187 r188 r186 into r189;
    is.eq r1[2u32][2u32] r6[1u32] into r190;
    add r189 1u8 into r191;
    ternary r190 r191 r189 into r192;
    is.eq r1[2u32][2u32] r6[2u32] into r193;
    add r192 1u8 into r194;
    ternary r193 r194 r192 into r195;
    is.eq r1[2u32][2u32] r6[3u32] into r196;
    add r195 1u8 into r197;
    ternary r196 r197 r195 into r198;
    is.eq r1[2u32][2u32] r6[4u32] into r199;
    add r198 1u8 into r200;
    ternary r199 r200 r198 into r201;
    is.eq r1[2u32][3u32] r6[0u32] into r202;
    add r201 1u8 into r203;
    ternary r202 r203 r201 into r204;
    is.eq r1[2u32][3u32] r6[1u32] into r205;
    add r204 1u8 into r206;
    ternary r205 r206 r204 into r207;
    is.eq r1[2u32][3u32] r6[2u32] into r208;
    add r207 1u8 into r209;
    ternary r208 r209 r207 into r210;
    is.eq r1[2u32][3u32] r6[3u32] into r211;
    add r210 1u8 into r212;
    ternary r211 r212 r210 into r213;
    is.eq r1[2u32][3u32] r6[4u32] into r214;
    add r213 1u8 into r215;
    ternary r214 r215 r213 into r216;
    is.eq r1[2u32][4u32] r6[0u32] into r217;
    add r216 1u8 into r218;
    ternary r217 r218 r216 into r219;
    is.eq r1[2u32][4u32] r6[1u32] into r220;
    add r219 1u8 into r221;
    ternary r220 r221 r219 into r222;
    is.eq r1[2u32][4u32] r6[2u32] into r223;
    add r222 1u8 into r224;
    ternary r223 r224 r222 into r225;
    is.eq r1[2u32][4u32] r6[3u32] into r226;
    add r225 1u8 into r227;
    ternary r226 r227 r225 into r228;
    is.eq r1[2u32][4u32] r6[4u32] into r229;
    add r228 1u8 into r230;
    ternary r229 r230 r228 into r231;
    is.eq r1[3u32][0u32] r6[0u32] into r232;
    add 0u8 1u8 into r233;
    ternary r232 r233 0u8 into r234;
    is.eq r1[3u32][0u32] r6[1u32] into r235;
    add r234 1u8 into r236;
    ternary r235 r236 r234 into r237;
    is.eq r1[3u32][0u32] r6[2u32] into r238;
    add r237 1u8 into r239;
    ternary r238 r239 r237 into r240;
    is.eq r1[3u32][0u32] r6[3u32] into r241;
    add r240 1u8 into r242;
    ternary r241 r242 r240 into r243;
    is.eq r1[3u32][0u32] r6[4u32] into r244;
    add r243 1u8 into r245;
    ternary r244 r245 r243 into r246;
    is.eq r1[3u32][1u32] r6[0u32] into r247;
    add r246 1u8 into r248;
    ternary r247 r248 r246 into r249;
    is.eq r1[3u32][1u32] r6[1u32] into r250;
    add r249 1u8 into r251;
    ternary r250 r251 r249 into r252;
    is.eq r1[3u32][1u32] r6[2u32] into r253;
    add r252 1u8 into r254;
    ternary r253 r254 r252 into r255;
    is.eq r1[3u32][1u32] r6[3u32] into r256;
    add r255 1u8 into r257;
    ternary r256 r257 r255 into r258;
    is.eq r1[3u32][1u32] r6[4u32] into r259;
    add r258 1u8 into r260;
    ternary r259 r260 r258 into r261;
    is.eq r1[3u32][2u32] r6[0u32] into r262;
    add r261 1u8 into r263;
    ternary r262 r263 r261 into r264;
    is.eq r1[3u32][2u32] r6[1u32] into r265;
    add r264 1u8 into r266;
    ternary r265 r266 r264 into r267;
    is.eq r1[3u32][2u32] r6[2u32] into r268;
    add r267 1u8 into r269;
    ternary r268 r269 r267 into r270;
    is.eq r1[3u32][2u32] r6[3u32] into r271;
    add r270 1u8 into r272;
    ternary r271 r272 r270 into r273;
    is.eq r1[3u32][2u32] r6[4u32] into r274;
    add r273 1u8 into r275;
    ternary r274 r275 r273 into r276;
    is.eq r1[3u32][3u32] r6[0u32] into r277;
    add r276 1u8 into r278;
    ternary r277 r278 r276 into r279;
    is.eq r1[3u32][3u32] r6[1u32] into r280;
    add r279 1u8 into r281;
    ternary r280 r281 r279 into r282;
    is.eq r1[3u32][3u32] r6[2u32] into r283;
    add r282 1u8 into r284;
    ternary r283 r284 r282 into r285;
    is.eq r1[3u32][3u32] r6[3u32] into r286;
    add r285 1u8 into r287;
    ternary r286 r287 r285 into r288;
    is.eq r1[3u32][3u32] r6[4u32] into r289;
    add r288 1u8 into r290;
    ternary r289 r290 r288 into r291;
    is.eq r1[3u32][4u32] r6[0u32] into r292;
    add r291 1u8 into r293;
    ternary r292 r293 r291 into r294;
    is.eq r1[3u32][4u32] r6[1u32] into r295;
    add r294 1u8 into r296;
    ternary r295 r296 r294 into r297;
    is.eq r1[3u32][4u32] r6[2u32] into r298;
    add r297 1u8 into r299;
    ternary r298 r299 r297 into r300;
    is.eq r1[3u32][4u32] r6[3u32] into r301;
    add r300 1u8 into r302;
    ternary r301 r302 r300 into r303;
    is.eq r1[3u32][4u32] r6[4u32] into r304;
    add r303 1u8 into r305;
    ternary r304 r305 r303 into r306;
    is.eq r1[4u32][0u32] r6[0u32] into r307;
    add 0u8 1u8 into r308;
    ternary r307 r308 0u8 into r309;
    is.eq r1[4u32][0u32] r6[1u32] into r310;
    add r309 1u8 into r311;
    ternary r310 r311 r309 into r312;
    is.eq r1[4u32][0u32] r6[2u32] into r313;
    add r312 1u8 into r314;
    ternary r313 r314 r312 into r315;
    is.eq r1[4u32][0u32] r6[3u32] into r316;
    add r315 1u8 into r317;
    ternary r316 r317 r315 into r318;
    is.eq r1[4u32][0u32] r6[4u32] into r319;
    add r318 1u8 into r320;
    ternary r319 r320 r318 into r321;
    is.eq r1[4u32][1u32] r6[0u32] into r322;
    add r321 1u8 into r323;
    ternary r322 r323 r321 into r324;
    is.eq r1[4u32][1u32] r6[1u32] into r325;
    add r324 1u8 into r326;
    ternary r325 r326 r324 into r327;
    is.eq r1[4u32][1u32] r6[2u32] into r328;
    add r327 1u8 into r329;
    ternary r328 r329 r327 into r330;
    is.eq r1[4u32][1u32] r6[3u32] into r331;
    add r330 1u8 into r332;
    ternary r331 r332 r330 into r333;
    is.eq r1[4u32][1u32] r6[4u32] into r334;
    add r333 1u8 into r335;
    ternary r334 r335 r333 into r336;
    is.eq r1[4u32][2u32] r6[0u32] into r337;
    add r336 1u8 into r338;
    ternary r337 r338 r336 into r339;
    is.eq r1[4u32][2u32] r6[1u32] into r340;
    add r339 1u8 into r341;
    ternary r340 r341 r339 into r342;
    is.eq r1[4u32][2u32] r6[2u32] into r343;
    add r342 1u8 into r344;
    ternary r343 r344 r342 into r345;
    is.eq r1[4u32][2u32] r6[3u32] into r346;
    add r345 1u8 into r347;
    ternary r346 r347 r345 into r348;
    is.eq r1[4u32][2u32] r6[4u32] into r349;
    add r348 1u8 into r350;
    ternary r349 r350 r348 into r351;
    is.eq r1[4u32][3u32] r6[0u32] into r352;
    add r351 1u8 into r353;
    ternary r352 r353 r351 into r354;
    is.eq r1[4u32][3u32] r6[1u32] into r355;
    add r354 1u8 into r356;
    ternary r355 r356 r354 into r357;
    is.eq r1[4u32][3u32] r6[2u32] into r358;
    add r357 1u8 into r359;
    ternary r358 r359 r357 into r360;
    is.eq r1[4u32][3u32] r6[3u32] into r361;
    add r360 1u8 into r362;
    ternary r361 r362 r360 into r363;
    is.eq r1[4u32][3u32] r6[4u32] into r364;
    add r363 1u8 into r365;
    ternary r364 r365 r363 into r366;
    is.eq r1[4u32][4u32] r6[0u32] into r367;
    add r366 1u8 into r368;
    ternary r367 r368 r366 into r369;
    is.eq r1[4u32][4u32] r6[1u32] into r370;
    add r369 1u8 into r371;
    ternary r370 r371 r369 into r372;
    is.eq r1[4u32][4u32] r6[2u32] into r373;
    add r372 1u8 into r374;
    ternary r373 r374 r372 into r375;
    is.eq r1[4u32][4u32] r6[3u32] into r376;
    add r375 1u8 into r377;
    ternary r376 r377 r375 into r378;
    is.eq r1[4u32][4u32] r6[4u32] into r379;
    add r378 1u8 into r380;
    ternary r379 r380 r378 into r381;
    cast  r81 r156 r231 r306 r381 into r382 as [u8; 5u32];
    get winning_price[true] into r383;
    is.eq r382[0u32] 1u8 into r384;
    add 0u64 r383[1u32] into r385;
    not r384 into r386;
    is.eq r382[0u32] 2u8 into r387;
    add 0u64 r383[2u32] into r388;
    not r387 into r389;
    is.eq r382[0u32] 3u8 into r390;
    add 0u64 r383[3u32] into r391;
    not r390 into r392;
    is.eq r382[0u32] 4u8 into r393;
    add 0u64 r383[4u32] into r394;
    not r393 into r395;
    is.eq r382[0u32] 5u8 into r396;
    add 0u64 r383[5u32] into r397;
    not r396 into r398;
    add 0u64 0u64 into r399;
    ternary r396 r397 r399 into r400;
    ternary r393 r394 r400 into r401;
    ternary r390 r391 r401 into r402;
    ternary r387 r388 r402 into r403;
    ternary r384 r385 r403 into r404;
    is.eq r382[1u32] 1u8 into r405;
    add r404 r383[1u32] into r406;
    not r405 into r407;
    is.eq r382[1u32] 2u8 into r408;
    add r404 r383[2u32] into r409;
    not r408 into r410;
    is.eq r382[1u32] 3u8 into r411;
    add r404 r383[3u32] into r412;
    not r411 into r413;
    is.eq r382[1u32] 4u8 into r414;
    add r404 r383[4u32] into r415;
    not r414 into r416;
    is.eq r382[1u32] 5u8 into r417;
    add r404 r383[5u32] into r418;
    not r417 into r419;
    add r404 0u64 into r420;
    ternary r417 r418 r420 into r421;
    ternary r414 r415 r421 into r422;
    ternary r411 r412 r422 into r423;
    ternary r408 r409 r423 into r424;
    ternary r405 r406 r424 into r425;
    is.eq r382[2u32] 1u8 into r426;
    add r425 r383[1u32] into r427;
    not r426 into r428;
    is.eq r382[2u32] 2u8 into r429;
    add r425 r383[2u32] into r430;
    not r429 into r431;
    is.eq r382[2u32] 3u8 into r432;
    add r425 r383[3u32] into r433;
    not r432 into r434;
    is.eq r382[2u32] 4u8 into r435;
    add r425 r383[4u32] into r436;
    not r435 into r437;
    is.eq r382[2u32] 5u8 into r438;
    add r425 r383[5u32] into r439;
    not r438 into r440;
    add r425 0u64 into r441;
    ternary r438 r439 r441 into r442;
    ternary r435 r436 r442 into r443;
    ternary r432 r433 r443 into r444;
    ternary r429 r430 r444 into r445;
    ternary r426 r427 r445 into r446;
    is.eq r382[3u32] 1u8 into r447;
    add r446 r383[1u32] into r448;
    not r447 into r449;
    is.eq r382[3u32] 2u8 into r450;
    add r446 r383[2u32] into r451;
    not r450 into r452;
    is.eq r382[3u32] 3u8 into r453;
    add r446 r383[3u32] into r454;
    not r453 into r455;
    is.eq r382[3u32] 4u8 into r456;
    add r446 r383[4u32] into r457;
    not r456 into r458;
    is.eq r382[3u32] 5u8 into r459;
    add r446 r383[5u32] into r460;
    not r459 into r461;
    add r446 0u64 into r462;
    ternary r459 r460 r462 into r463;
    ternary r456 r457 r463 into r464;
    ternary r453 r454 r464 into r465;
    ternary r450 r451 r465 into r466;
    ternary r447 r448 r466 into r467;
    is.eq r382[4u32] 1u8 into r468;
    add r467 r383[1u32] into r469;
    not r468 into r470;
    is.eq r382[4u32] 2u8 into r471;
    add r467 r383[2u32] into r472;
    not r471 into r473;
    is.eq r382[4u32] 3u8 into r474;
    add r467 r383[3u32] into r475;
    not r474 into r476;
    is.eq r382[4u32] 4u8 into r477;
    add r467 r383[4u32] into r478;
    not r477 into r479;
    is.eq r382[4u32] 5u8 into r480;
    add r467 r383[5u32] into r481;
    not r480 into r482;
    add r467 0u64 into r483;
    ternary r480 r481 r483 into r484;
    ternary r477 r478 r484 into r485;
    ternary r474 r475 r485 into r486;
    ternary r471 r472 r486 into r487;
    ternary r468 r469 r487 into r488;
    get.or_use user_balance[r0] 0u64 into r489;
    set r488 into user_balance[r0];

function claim:
    input r0 as u64.private;
    gt r0 0u64 into r1;
    assert.eq r1 true;
    hash.bhp256 self.caller into r2 as field;
    call credits.aleo/transfer_public_to_private self.caller r0 into r3 r4;
    async claim r2 r0 r4 into r5;
    output r3 as credits.aleo/credits.record;
    output r5 as lottery_game_puri.aleo/claim.future;

finalize claim:
    input r0 as field.public;
    input r1 as u64.public;
    input r2 as credits.aleo/transfer_public_to_private.future;
    await r2;
    assert.eq true true;
    get status[true] into r3;
    assert.eq r3 1u8;
    get user_balance[r0] into r4;
    gte r4 r1 into r5;
    assert.eq r5 true;
    sub r4 r1 into r6;
    set r6 into user_balance[r0];

function transfer_ownership:
    input r0 as address.public;
    async transfer_ownership self.caller r0 into r1;
    output r1 as lottery_game_puri.aleo/transfer_ownership.future;

finalize transfer_ownership:
    input r0 as address.public;
    input r1 as address.public;
    get admin[true] into r2;
    assert.eq r0 r2;
    set r1 into admin[true];

function unpause:
    async unpause self.caller into r0;
    output r0 as lottery_game_puri.aleo/unpause.future;

finalize unpause:
    input r0 as address.public;
    get admin[true] into r1;
    assert.eq r0 r1;
    set 1u8 into status[true];

function pause:
    async pause self.caller into r0;
    output r0 as lottery_game_puri.aleo/pause.future;

finalize pause:
    input r0 as address.public;
    get admin[true] into r1;
    assert.eq r0 r1;
    set 0u8 into status[true];

function withdraw:
    input r0 as u64.private;
    call credits.aleo/transfer_public self.caller r0 into r1;
    async withdraw r0 self.caller r1 into r2;
    output r2 as lottery_game_puri.aleo/withdraw.future;

finalize withdraw:
    input r0 as u64.public;
    input r1 as address.public;
    input r2 as credits.aleo/transfer_public.future;
    await r2;
    get admin[true] into r3;
    assert.eq r1 r3;
